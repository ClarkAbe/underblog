  <rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
      <channel>
          <title>Clark&#39;s Blog</title>
          <link>http://example.com</link>
          <description>Blog about underblog</description>
          <atom:link href="http://example.com/rss.xml" rel="self" type="application/rss+xml" />
          <item>
              <title>archlinux开机自动挂载磁盘</title>
              <link>http://example.com/posts/archstartdisk</link>
              <guid>http://example.com/posts/archstartdisk</guid>
              <description>&#xA;###### 来源:https://blog.hellojukay.cn/2018/03/28/20180401/&#xA;###### Tag: #Linux #系统知识 #磁盘&#xA;&#xA;我的这台archlinux的主板上接了一个2TB的硬盘，每次开机启动他斗没有自动挂载上来，我总是在自己需要使用这硬盘的时候来手动挂载他，这样太不方便了，我想能不能在开机的时候自动来挂载这个块硬盘。解决这个问题的方法是有的，往/etc/fstab这个文件的后面加入的分区信息和挂载点&#xA;&#xA;```&#xA;[hellojukay@archlinux ~]$ cat /etc/fstab &#xA;# Static information about the filesystems.&#xA;# See fstab(5) for details.&#xA;&#xA;# &amp;lt;file system&amp;gt; &amp;lt;dir&amp;gt; &amp;lt;type&amp;gt; &amp;lt;options&amp;gt; &amp;lt;dump&amp;gt; &amp;lt;pass&amp;gt;&#xA;# /dev/sda3&#xA;UUID=e3a426e2-4713-4b33-ad6c-773bf144081c&#x9;/         &#x9;ext4      &#x9;rw,relatime,data=ordered&#x9;0 1&#xA;&#xA;# /dev/sda1&#xA;UUID=1b43aa57-22fc-4af2-8a84-cd8f6e27e8f2&#x9;/boot     &#x9;ext4      &#x9;rw,relatime,data=ordered&#x9;0 2&#xA;&#xA;# /dev/sda5&#xA;UUID=2d6bde7f-b18c-44e1-8036-8ecdd93c13c1&#x9;/home     &#x9;ext4      &#x9;rw,relatime,data=ordered&#x9;0 2&#xA;&#xA;# /dev/sda2&#xA;UUID=6bbfba42-07ec-479a-b9fa-d3e89e94af9f&#x9;none      &#x9;swap      &#x9;defaults,pri=-2&#x9;0 0&#xA;```&#xA;&#xA;这个需要知道的分区的UUID,使用blkid命令能看到分区的id，一下是我的挂载的情况&#xA;```&#xA;[hellojukay@archlinux ~]$ sudo lsblk&#xA;NAME   MAJ:MIN RM   SIZE RO TYPE MOUNTPOINT&#xA;sda      8:0    0 111.8G  0 disk &#xA;├─sda1   8:1    0   100M  0 part /boot&#xA;├─sda2   8:2    0    20G  0 part [SWAP]&#xA;├─sda3   8:3    0    50G  0 part /&#xA;├─sda4   8:4    0     1K  0 part &#xA;└─sda5   8:5    0    10G  0 part /home&#xA;sdb      8:16   0   1.8T  0 disk &#xA;└─sdb1   8:17   0   1.8T  0 part /data&#xA;sr0     11:0    1 127.5M  0 rom  /run/media/hellojukay/TP-LINK&#xA;[hellojukay@archlinux ~]$&#xA;```&#xA;&#xA;这个的磁盘sdb就是我的那个2TB的磁盘，他没有被挂载在任何目录下，我们来看下/dev/sdb1的UUID.&#xA;```&#xA;[hellojukay@archlinux ~]$ sudo blkid  /dev/sdb1&#xA;/dev/sdb1: PARTUUID=&amp;#34;0cfc53f7-01&amp;#34;&#xA;[hellojukay@archlinux ~]$&#xA;```&#xA;&#xA;这里的sdb就是我需要挂载的外置因盘，我们来看一下他的分区的UUID,&#xA;```&#xA;[hellojukay@archlinux blog]$ sudo blkid /dev/sdb1&#xA;/dev/sdb1: UUID=&amp;#34;7d546d07-1049-4a4a-92a4-152d1c7ba854&amp;#34; TYPE=&amp;#34;ext4&amp;#34; PARTUUID=&amp;#34;0cfc53f7-01&amp;#34;&#xA;```&#xA;&#xA;这里看到了，sdb1的UUID了，只需要他他写入到/etc/fstab重，开启启动就会自动挂载的&#xA;```&#xA;[hellojukay@archlinux blog]$ cat /etc/fstab &#xA;# Static information about the filesystems.&#xA;# See fstab(5) for details.&#xA;&#xA;# &amp;lt;file system&amp;gt; &amp;lt;dir&amp;gt; &amp;lt;type&amp;gt; &amp;lt;options&amp;gt; &amp;lt;dump&amp;gt; &amp;lt;pass&amp;gt;&#xA;# /dev/sda3&#xA;UUID=e3a426e2-4713-4b33-ad6c-773bf144081c&#x9;/         &#x9;ext4      &#x9;rw,relatime,data=ordered&#x9;0 1&#xA;&#xA;# /dev/sda1&#xA;UUID=1b43aa57-22fc-4af2-8a84-cd8f6e27e8f2&#x9;/boot     &#x9;ext4      &#x9;rw,relatime,data=ordered&#x9;0 2&#xA;&#xA;# /dev/sda5&#xA;UUID=2d6bde7f-b18c-44e1-8036-8ecdd93c13c1&#x9;/home     &#x9;ext4      &#x9;rw,relatime,data=ordered&#x9;0 2&#xA;&#xA;# /dev/sda2&#xA;UUID=6bbfba42-07ec-479a-b9fa-d3e89e94af9f&#x9;none      &#x9;swap      &#x9;defaults,pri=-2&#x9;0 0&#xA;&#xA;# /dev/sdb1&#xA;UUID=7d546d07-1049-4a4a-92a4-152d1c7ba854       /data           ext4            defaults                         0 0&#xA;```&#xA;&#xA;我们已经把这块硬盘挂载到了/data目录下了。 &#xA;</description>
              <pubDate>Fri, 12 Jun 2020 00:00:00 +0000</pubDate>
          </item>
          <item>
              <title>【探索】利用 canvas 实现数据压缩</title>
              <link>http://example.com/posts/QAQ</link>
              <guid>http://example.com/posts/QAQ</guid>
              <description>&#xA;###### 来源:https://www.cnblogs.com/index-html/p/canvas_data_compress.html&#xA;### 前言&#xA;&#xA;HTTP 支持 GZip 压缩，可节省不少传输资源。但遗憾的是，只有下载才有，上传并不支持。如果上传也能压缩，那就完美了。特别适合大量文本提交的场合，比如博客园，就是很好的例子。&#xA;&#xA;虽然标准不支持「上传压缩」，但仍可以自己来实现。&#xA;#### Flash&#xA;&#xA;首选方案当然是 Flash，毕竟它提供了压缩 API。除了 zip 格式，还支持 lzma 这种超级压缩。因为是原生接口，所以性能极高。而且对应的 swf 文件，也非常小。&#xA;#### JavaScript&#xA;&#xA;Flash 逐渐淘汰，但取而代之的 HTML5，却没有提供压缩 API。只能自己用 JS 实现。&#xA;&#xA;这虽然可行，但运行速度就慢多了，而且相应的 JS 也很大。如果代码有 50kb，而数据压缩后只小 10kb，那就不值了。除非量大，才有意义。&#xA;其他&#xA;&#xA;能否不用 JS，而是利用某些接口，间接实现压缩？事实上，在 HTML5 刚出现时，就注意到了一个功能：canvas 导出图片。可以生成 JPG、PNG 等格式。&#xA;&#xA;如果在思考的话，相信你也想到了。没错，就是 PNG —— 它是无损压缩的图片格式。我们把普通数据当成像素点，画到 canvas 上，然后导出成 PNG，不就是一个特殊的压缩包了吗！&#xA;&#xA;下面开始探索。。。&#xA;#### 编码&#xA;&#xA;数据转像素，并不麻烦。1 个像素可以容纳 4 个字节：&#xA;```javascript&#xA;R = bytes[0]&#xA;G = bytes[1]&#xA;B = bytes[2]&#xA;A = bytes[3]&#xA;```&#xA;事实上有现成的方法，可批量将数据填充成像素：&#xA;```javascript&#xA;var img = new ImageData(bytes, w, h);&#xA;context.putImageData(img, 0, 0);&#xA;```&#xA;但是，图片的宽高如何设定？&#xA;尺寸&#xA;&#xA;最简单的，就是用 1px 的高度。比如有 1000 个像素，则填在 1000 x 1 的图片里。&#xA;&#xA;但如果有 10000 像素，就不可行了。因为 canvas 的尺寸，是有限制的。&#xA;&#xA;不同的浏览器，最大尺寸不一样。有 4096 的，也有 32767 的。。。&#xA;&#xA;以最大 4096 为例，如果每次都用这个宽度，显然不合理。&#xA;&#xA;比如有 n = 4100 个像素，我们使用 4096 x 2 的尺寸：&#xA;&#xA;| 1    | 2    | 3    | 4    | ...  | 4095 | 4096 |&#xA;| 4097 | 4098 | 4099 | 4100 | ...... 未利用 ......&#xA;&#xA;第二行只用到 4 个，剩下的 4092 个都空着了。&#xA;&#xA;但 4100 = 41 * 100。如果用这个尺寸，就不会有浪费。&#xA;&#xA;所以，得对 n 分解因数：&#xA;&#xA;n = w * h&#xA;&#xA;这样就能将 n 个像素，正好填满 w x h 的图片。&#xA;&#xA;但 n 是质数的话，就无解了。这时浪费就不可避免了，只是，怎样才能浪费最少？&#xA;&#xA;于是就变成这样一个问题：&#xA;&#xA;   如何用 n + m 个点，拼成一个矩形。求矩形的 w 和 h。（n 已知，m 越小越好，0 &amp;lt; w &amp;lt;= MAX, 0 &amp;lt; h &amp;lt;= MAX）&#xA;&#xA;考虑到 MAX 不大，穷举就可以。&#xA;&#xA;我们遍历 h，计算相应的 w = ceil(n / h)， 然后找出最接近 n 的 w * h。&#xA;```javascript&#xA;var MAX = 4096;&#xA;var beg = Math.ceil(n / MAX);&#xA;var end = Math.ceil(Math.sqrt(n));&#xA;&#xA;var minSize = 9e9;&#xA;&#xA;var bestH = 0,          // 最终结果&#xA;    bestW = 0;&#xA;&#xA;for (h = beg; h &amp;lt;= end; h++) {&#xA;    var w = Math.ceil(n / h);&#xA;    var size = w * h;&#xA;&#xA;    if (size &amp;lt; minSize) {&#xA;        minSize = size;&#xA;        bestW = w;&#xA;        bestH = h;&#xA;    }&#xA;    if (size == n) {&#xA;        break;&#xA;    }&#xA;}&#xA;```&#xA;因为 w * h 和 h * w 是一样的，所以只需遍历到 sqrt(n) 就可以。&#xA;&#xA;同样，也无需从 1 开始，从 n / MAX 即可。&#xA;&#xA;这样，我们就能找到最适合的图片尺寸。&#xA;&#xA;   当然，连续的空白像素，最终压缩后会很小。这一步其实并不特别重要。&#xA;&#xA;#### 渲染&#xA;&#xA;定下尺寸，我们就可以「渲染数据」了。&#xA;&#xA;渲染看似简单，然而事实上却有个意想不到的坑 —— 同个像素写入后再读取，数据居然会有偏差！这里有个测试：&#xA;```javascript&#xA;var canvas = document.createElement(&amp;#39;canvas&amp;#39;);&#xA;var ctx = canvas.getContext(&amp;#39;2d&amp;#39;);&#xA;&#xA;// 写入的数据&#xA;var bytes = [100, 101, 102, 103];&#xA;&#xA;var buf = new Uint8ClampedArray(bytes);&#xA;var img = new ImageData(buf, 1, 1);&#xA;ctx.putImageData(img, 0, 0);&#xA;&#xA;// 读取的数据&#xA;img = ctx.getImageData(0, 0, 1, 1);&#xA;console.log(img.data);&#xA;&#xA;// 期望     [100, 101, 102, 103]&#xA;// 实际&#xA;// chrome  [99,  102, 102, 103]&#xA;// firefox [101, 101, 103, 103]&#xA;// ...&#xA;```&#xA;读取的值和写入的很接近，但并不相同。而且不同的浏览器，偏差还不一样！这究竟是怎么回事？&#xA;&#xA;原来，浏览器为了提高渲染性能，有一个 Premultiplied Alpha 的机制。但是，这会牺牲一些精度！虽然视觉上并不明显，但用于数据存储，就有问题了。&#xA;&#xA;如何禁用它？一番尝试都没成功。于是，只能从数据上琢磨。如果不使用 Alpha 通道，又会怎样？&#xA;```javascript&#xA;// 写入的数据&#xA;var bytes = [100, 101, 102, 255];&#xA;...&#xA;console.log(img.data);  // [100, 101, 102, 255]&#xA;&#xA;设置 A = 255，这样倒是避开了问题。&#xA;&#xA;看来，只能从数据上着手，跳过 Alpha 通道：&#xA;&#xA;// pixel 1&#xA;new_bytes[0] = bytes[0]     // R&#xA;new_bytes[1] = bytes[1]     // G&#xA;new_bytes[2] = bytes[2]     // B&#xA;new_bytes[3] = 255          // A&#xA;&#xA;// pixel 2&#xA;new_bytes[4] = bytes[3]     // R&#xA;new_bytes[5] = bytes[4]     // G&#xA;new_bytes[6] = bytes[5]     // B&#xA;new_bytes[7] = 255          // A&#xA;&#xA;...&#xA;```&#xA;这时，就不受 Premultiplied Alpha 的影响了。&#xA;&#xA;出于简单，也可以 1 像素存 1 字节：&#xA;```javascript&#xA;// pixel 1&#xA;new_bytes[0] = bytes[0]&#xA;new_bytes[1] = 255&#xA;new_bytes[2] = 255&#xA;new_bytes[3] = 255&#xA;&#xA;// pixel 2&#xA;new_bytes[4] = bytes[1]&#xA;new_bytes[5] = 255&#xA;new_bytes[6] = 255&#xA;new_bytes[7] = 255&#xA;&#xA;...&#xA;```&#xA;这样，整个图片最多只有 256 色。如果能导出成「索引型 PNG」的话，也是可以尝试的。&#xA;#### 解码&#xA;&#xA;最后，就是将图像导出成可传输的数据。如果 canvas 能直接导出成 blob，那是最好的，因为 blob 可通过 AJAX 上传。&#xA;```javascript&#xA;canvas.toBlob(function(blob) {&#xA;    // ...&#xA;}, &amp;#39;image/png&amp;#39;)&#xA;```&#xA;不过，大多浏览器都不支持，只能导出 data uri 格式：&#xA;```javascript&#xA;uri = canvas.toDataURL(&amp;#39;image/png&amp;#39;)  // data:image/png;base64,xxxx&#xA;```&#xA;然而 base64 会增加 1/3 的长度，这样压缩效果就大幅降低了。所以，我们还得解码成二进制：&#xA;```javascript&#xA;base64 = uri.substr(uri.indexOf(&amp;#39;,&amp;#39;) + 1)&#xA;binary = atob(base64)&#xA;```&#xA;这时的 binary，就是最终想要的数据了吗？如果将 binary 通过 AJAX 提交的话，会发现实际传输字节，会比 binary.length 大！&#xA;&#xA;原来 atob 函数返回的数据，仍是字符串型的，所以传输时会涉及到字集编码。因此我们还需再转换一次，变成真正的二进制类型：&#xA;```javascript&#xA;var len = binary.length&#xA;var buf = new Uint8Array(len)&#xA;&#xA;for (var i = 0; i &amp;lt; len; i++) {&#xA;    buf[i] = binary.charCodeAt(i)&#xA;}&#xA;```&#xA;这时的 buf，才能被 AJAX 原封不动的传输。&#xA;#### 演示&#xA;&#xA;综上所述，我们简单演示下：https://www.etherdream.com/FunnyScript/jszip/encode.html&#xA;```html&#xA;&amp;lt;html&amp;gt;&#xA;&amp;lt;head&amp;gt;&#xA;  &amp;lt;title&amp;gt;PNG 压缩数据&amp;lt;/title&amp;gt;&#xA;  &amp;lt;meta charset=&amp;#34;utf-8&amp;#34; /&amp;gt;&#xA;  &amp;lt;style&amp;gt;&#xA;    #txtContent {&#xA;      width: 800px;&#xA;      height: 300px;&#xA;    }&#xA;    #txtResult {&#xA;      width: 800px;&#xA;      height: 100px;&#xA;    }&#xA;&#xA;    canvas {&#xA;      border: 2px solid #000;&#xA;    }&#xA;  &amp;lt;/style&amp;gt;&#xA;&amp;lt;/head&amp;gt;&#xA;&amp;lt;body&amp;gt;&#xA;  &amp;lt;div&amp;gt;&#xA;    &amp;lt;span&amp;gt;压缩文字：&amp;lt;/span&amp;gt;&#xA;    &amp;lt;a href=&amp;#34;javascript:load(&amp;#39;t1.txt&amp;#39;)&amp;#34;&amp;gt;测试内容&amp;lt;/a&amp;gt;&#xA;  &amp;lt;/div&amp;gt;&#xA;  &amp;lt;div&amp;gt;&#xA;    &amp;lt;textarea id=&amp;#34;txtContent&amp;#34;&amp;gt;&amp;lt;/textarea&amp;gt;&#xA;  &amp;lt;/div&amp;gt;&#xA;  &amp;lt;div&amp;gt;&#xA;    &amp;lt;span&amp;gt;编码方式：&amp;lt;/span&amp;gt;&#xA;    &amp;lt;select id=&amp;#34;selEncType&amp;#34;&amp;gt;&#xA;      &amp;lt;option value=&amp;#34;1px_1byte&amp;#34;&amp;gt;每像素 1 字节&amp;lt;/option&amp;gt;&#xA;      &amp;lt;option value=&amp;#34;1px_3byte&amp;#34;&amp;gt;每像素 3 字节&amp;lt;/option&amp;gt;&#xA;    &amp;lt;/select&amp;gt;&#xA;    &amp;lt;button id=&amp;#34;btnCompress&amp;#34;&amp;gt;压缩&amp;lt;/button&amp;gt;&#xA;  &amp;lt;/div&amp;gt;&#xA;  &amp;lt;div&amp;gt;&#xA;    &amp;lt;textarea id=&amp;#34;txtResult&amp;#34; readonly&amp;gt;&amp;lt;/textarea&amp;gt;&#xA;  &amp;lt;/div&amp;gt;&#xA;  &amp;lt;script&amp;gt;&#xA;    function find_best_size(pixelCount) {&#xA;      // canvas max width or height&#xA;      var MAX_L = 4096;&#xA;&#xA;      var sqrt = Math.ceil(Math.sqrt(pixelCount));&#xA;      if (sqrt &amp;gt; MAX_L) {&#xA;        return null;&#xA;      }&#xA;&#xA;      var minL = Math.ceil(pixelCount / MAX_L);&#xA;      var minS = 1e9;&#xA;      var bestH = 0, bestW = 0;&#xA;&#xA;      for (var h = minL; h &amp;lt;= sqrt; h++) {&#xA;        var w = Math.ceil(pixelCount / h);&#xA;        var size = w * h;&#xA;        if (size &amp;lt; minS) {&#xA;          minS = size;&#xA;          bestW = w;&#xA;          bestH = h;&#xA;        }&#xA;        if (size == pixelCount) {&#xA;          break;&#xA;        }&#xA;      }&#xA;      return {w: bestW, h: bestH};&#xA;    }&#xA;&#xA;&#xA;    function str_to_bytes(str) {&#xA;      var len = str.length;&#xA;      var buf = new Uint8Array(len);&#xA;&#xA;      for (var i = 0; i &amp;lt; len; i++) {&#xA;        buf[i] = str.charCodeAt(i);&#xA;      }&#xA;      return buf;&#xA;    }&#xA;&#xA;&#xA;    // 每像素存 1 字节&#xA;    function encode_1px_1byte(bytes) {&#xA;      var count = bytes.length;&#xA;      var size = find_best_size(count);&#xA;&#xA;      var buffer = new ArrayBuffer(size.w * size.h * 4);&#xA;      var u32Ptr = new Uint32Array(buffer);&#xA;&#xA;      // R: bytes[i], G: FF, B: FF, A: FF&#xA;&#xA;      for (var i = 0; i &amp;lt; count; i++) {&#xA;        u32Ptr[i] = bytes[i] | 0xFFFFFF00;  // 0xAABBGGRR&#xA;      }&#xA;&#xA;      var u8Ptr = new Uint8ClampedArray(buffer);&#xA;      return new ImageData(u8Ptr, size.w, size.h);&#xA;    }&#xA;&#xA;&#xA;    // 每像素存 3 字节&#xA;    function encode_1px_3byte(bytes) {&#xA;      var count = Math.ceil(bytes.length / 3);&#xA;      var size = find_best_size(count);&#xA;&#xA;      var buffer = new ArrayBuffer(size.w * size.h * 4);&#xA;      var u32Ptr = new Uint32Array(buffer);&#xA;&#xA;      // R: bytes[i], G: bytes[i+1], B: bytes[i+2], A: FF&#xA;&#xA;      // 数组越界返回 undefined，位运算时当做 0&#xA;      for (var i = 0, j = 0; i &amp;lt; count; i++, j += 3) {&#xA;        u32Ptr[i] =             // 0xAABBGGRR&#xA;          bytes[j + 0] &amp;lt;&amp;lt;  0 |  // R &#xA;          bytes[j + 1] &amp;lt;&amp;lt;  8 |  // G&#xA;          bytes[j + 2] &amp;lt;&amp;lt; 16 |  // B&#xA;          0xFF000000;           // A&#xA;      }&#xA;&#xA;      var u8Ptr = new Uint8ClampedArray(buffer);&#xA;      return new ImageData(u8Ptr, size.w, size.h);&#xA;    }&#xA;&#xA;    var ENCODE_TYPE = {&#xA;      &amp;#39;1px_3byte&amp;#39;: encode_1px_3byte,&#xA;      &amp;#39;1px_1byte&amp;#39;: encode_1px_1byte&#xA;    };&#xA;&#xA;&#xA;    function compress(bytes, type, callback) {&#xA;      var fn = ENCODE_TYPE[type];&#xA;      var img = fn(bytes);&#xA;&#xA;      var canvas = document.createElement(&amp;#39;canvas&amp;#39;);&#xA;      canvas.width = img.width;&#xA;      canvas.height = img.height;&#xA;      canvas.getContext(&amp;#39;2d&amp;#39;).putImageData(img, 0, 0);&#xA;&#xA;      if (canvas.toBlob) {    // fast way&#xA;        canvas.toBlob(callback, &amp;#39;image/png&amp;#39;);&#xA;      } else {&#xA;        // canvas to base64&#xA;        var uri = canvas.toDataURL(&amp;#39;image/png&amp;#39;);&#xA;        var base64 = uri.substr(uri.indexOf(&amp;#39;,&amp;#39;) + 1);&#xA;&#xA;        // base64 to binStr&#xA;        var binStr = atob(base64);&#xA;&#xA;        // binStr to uint8[]&#xA;        var bytes = str_to_bytes(binStr);&#xA;&#xA;        callback(bytes);&#xA;      }&#xA;&#xA;      // for test&#xA;      document.body.appendChild(canvas);&#xA;    }&#xA;&#xA;&#xA;&#xA;    // ------------------------------&#xA;    // 测试代码&#xA;    // ------------------------------&#xA;    btnCompress.onclick = function() {&#xA;      var text = txtContent.value;&#xA;      if (!text) {&#xA;        return;&#xA;      }&#xA;&#xA;      var txt_bytes = utf8_to_bytes(text);&#xA;      var enc_type = selEncType.options[selEncType.selectedIndex].value;&#xA;      var tick = Date.now();&#xA;&#xA;      compress(txt_bytes, enc_type, function(result) {&#xA;        // blob or Uint8Array&#xA;        var png_len = result.length || result.size;&#xA;&#xA;        var log =&#xA;          &amp;#39;编码方式：&amp;#39; + enc_type + &amp;#39;\n&amp;#39; +&#xA;          &amp;#39;压缩前：&amp;#39; + txt_bytes.length + &amp;#39; 字节\n&amp;#39; +&#xA;          &amp;#39;压缩后：&amp;#39; + png_len + &amp;#39; 字节\n&amp;#39; +&#xA;          &amp;#39;压缩率：&amp;#39; + (png_len / txt_bytes.length * 100).toFixed(1) + &amp;#39;%\n&amp;#39; +&#xA;          &amp;#39;耗时：&amp;#39; + (Date.now() - tick) + &amp;#39;ms&amp;#39;;&#xA;&#xA;        console.log(log);&#xA;        txtResult.value = log;&#xA;      });&#xA;    }&#xA;&#xA;    function utf8_to_bytes(str) {&#xA;      var buf = [];&#xA;      var i = 0, j = 0;&#xA;&#xA;      var esc = encodeURI(str);&#xA;      var n = esc.length;&#xA;      while (i &amp;lt; n) {&#xA;        var ch = esc.charCodeAt(i);&#xA;        if (ch == 37) {   // &amp;#39;%&amp;#39;&#xA;          var hex = esc.substr(i + 1, 2);&#xA;          ch = parseInt(hex, 16);&#xA;          i += 3;&#xA;        } else {&#xA;          i++;&#xA;        }&#xA;        buf[j++] = ch;&#xA;      }&#xA;      return buf;&#xA;    }&#xA;&#xA;    function load(f) {&#xA;      var xhr = new XMLHttpRequest();&#xA;      xhr.open(&amp;#39;GET&amp;#39;, f, true);&#xA;      xhr.send();&#xA;      xhr.onload = function() {&#xA;        txtContent.value = xhr.responseText;&#xA;      };&#xA;    }&#xA;&#xA;&#xA;    if (!window.Uint8ClampedArray) {&#xA;      alert(&amp;#39;当前浏览器不支持&amp;#39;)&#xA;    }&#xA;  &amp;lt;/script&amp;gt;&#xA;&amp;lt;/body&amp;gt;&#xA;&amp;lt;/html&amp;gt;&#xA;&#xA;```&#xA;&#xA;&#xA;&#xA;找一个大块的文本测试。例如 qq.com 首页 HTML，有 637,101 字节。&#xA;&#xA;先使用「每像素 1 字节」的编码，各个浏览器生成的 PNG 大小：&#xA;Chrome &#x9;FireFox &#x9;Safari&#xA;体积 &#x9;289,460 &#x9;203,276 &#x9;478,994&#xA;比率 &#x9;45.4% &#x9;31.9% &#x9;75.2%&#xA;&#xA;其中火狐压缩率最高，减少了 2/3 的体积。生成的 PNG 看起来是这样的：&#xA;&#xA;![](/uploads/cv_blog/images/m_0f5089105e7dc53056fe82dd9f2e09b7_r.png)&#xA;&#xA;&amp;gt; 不过遗憾的是，所有浏览器生成的图片，都不是「256 色索引」的。&#xA;&#xA;再测试「每像素 3 字节」，看看会不会有改善：&#xA;Chrome &#x9;FireFox &#x9;Safari&#xA;体积 &#x9;297,239 &#x9;202,785 &#x9;384,183&#xA;比率 &#x9;46.7% &#x9;31.8% &#x9;60.3%&#xA;&#xA;Safari 有了不少的进步，不过 Chrome 却更糟了。&#xA;&#xA;FireFox 有略微的提升，压缩率仍是最高的。生成如下图片：&#xA;&#xA;![](/uploads/cv_blog/images/m_1cebcd38d838ddea63f471e9ce483d9b_r.png)&#xA;&#xA;#### 结论&#xA;&#xA;由于 canvas 导出图片时，无法设置压缩等级，而默认的压缩率并不高。所以这种方式，最终效果并不理想。&#xA;&#xA;同样的数据，相比 Flash 压缩，差距就很明显了：&#xA;deflate 算法 &#x9;lzma 算法&#xA;体积 &#x9;133,660 &#x9;108,015&#xA;比率 &#x9;21.0% &#x9;17.0%&#xA;&#xA;并且 Flash 生成的是通用格式，后端解压时，使用标准库即可；而 PNG 还得位图解码、像素处理等步骤，很麻烦。&#xA;&#xA;所以，现实中还是优先使用 Flash，本文只是开脑洞而已。&#xA;用例&#xA;&#xA;虽然是个然并卵的黑科技，不过实际还是有用到过，曾用在一个较大日志上传的场合（并且不能用 Flash）。&#xA;&#xA;好在后端仅仅储存而已，并不分析。所以，可以让管理员将日志对应的 PNG 图片下回本地，在自己电脑上解析。&#xA;&#xA;解压更容易，就是将像素还原回数据，这里有个简陋的 Demo：https://www.etherdream.com/FunnyScript/jszip/decode.html&#xA;&#xA;```html&#xA;&amp;lt;!doctype html&amp;gt;&#xA;&amp;lt;html&amp;gt;&#xA;&amp;lt;head&amp;gt;&#xA;  &amp;lt;title&amp;gt;PNG 数据解压&amp;lt;/title&amp;gt;&#xA;  &amp;lt;meta charset=&amp;#34;utf-8&amp;#34; /&amp;gt;&#xA;  &amp;lt;style&amp;gt;&#xA;    #txtURL {&#xA;      width: 500px;&#xA;    }&#xA;    #txtResult {&#xA;      width: 600px;&#xA;      height: 300px;&#xA;    }&#xA;  &amp;lt;/style&amp;gt;&#xA;&amp;lt;/head&amp;gt;&#xA;&amp;lt;body&amp;gt;&#xA;  &amp;lt;div&amp;gt;&#xA;    图片 URL：&amp;lt;input id=&amp;#34;txtURL&amp;#34; type=&amp;#34;text&amp;#34; value=&amp;#34;https://i.loli.net/2017/12/13/5a30dac33eca1.png&amp;#34;&amp;gt;&#xA;    &amp;lt;button id=&amp;#34;btnLoad&amp;#34;&amp;gt;加载&amp;lt;/button&amp;gt;&#xA;  &amp;lt;/div&amp;gt;&#xA;  &amp;lt;div&amp;gt;&#xA;    &amp;lt;textarea id=&amp;#34;txtResult&amp;#34;&amp;gt;&amp;lt;/textarea&amp;gt;&#xA;  &amp;lt;/div&amp;gt;&#xA;  &amp;lt;div id=&amp;#34;imgBox&amp;#34;&amp;gt;&#xA;    图片预览：&#xA;  &amp;lt;/div&amp;gt;&#xA;  &amp;lt;script&amp;gt;&#xA;    function uncompress(img) {&#xA;      var w = img.width;&#xA;      var h = img.height;&#xA;&#xA;      var canvas = document.createElement(&amp;#39;canvas&amp;#39;);&#xA;      canvas.width = w;&#xA;      canvas.height = h;&#xA;&#xA;      var ctx = canvas.getContext(&amp;#39;2d&amp;#39;);&#xA;      ctx.drawImage(img, 0, 0);&#xA;&#xA;      var imgData = ctx.getImageData(0, 0, w, h);&#xA;      var buf = imgData.data.buffer;&#xA;&#xA;      // FIX: remove padding&#xA;      return decode_1px_3byte(buf);&#xA;    }&#xA;&#xA;&#xA;    function decode_1px_3byte(buf) {&#xA;      var u32 = new Uint32Array(buf);&#xA;      var len = u32.length;&#xA;      var ret = new Uint8Array(len * 3);&#xA;      var p = 0;&#xA;&#xA;      for (var i = 0; i &amp;lt; len; i++) {&#xA;        var rgba = u32[i];&#xA;        ret[p++] = rgba;&#xA;        ret[p++] = rgba &amp;gt;&amp;gt;  8 &amp;amp; 0xff;&#xA;        ret[p++] = rgba &amp;gt;&amp;gt; 16 &amp;amp; 0xff;&#xA;      }&#xA;      return ret;&#xA;    }&#xA;&#xA;&#xA;    btnLoad.onclick = function() {&#xA;      btnLoad.disabled = true;&#xA;      txtResult.value = &amp;#39;loading...&amp;#39;;&#xA;&#xA;      var img = new Image();&#xA;&#xA;      // debug&#xA;      imgBox.appendChild(img);&#xA;&#xA;      img.onload = function() {&#xA;        btnLoad.disabled = false;&#xA;&#xA;        var bytes = uncompress(img);&#xA;        var dec = new TextDecoder();&#xA;        txtResult.value = dec.decode(bytes);&#xA;      };&#xA;&#xA;      img.onerror = function() {&#xA;        btnLoad.disabled = false;&#xA;        txtResult.value = &amp;#39;load error!&amp;#39;;&#xA;      };&#xA;&#xA;      img.crossOrigin = true;&#xA;      img.referrerPolicy = &amp;#39;no-referrer&amp;#39;;&#xA;      img.src = txtURL.value;&#xA;    };&#xA;  &amp;lt;/script&amp;gt;&#xA;&amp;lt;/body&amp;gt;&#xA;&amp;lt;/html&amp;gt;&#xA;&#xA;```&#xA;&#xA;&#xA;&#xA;&#xA;这样，既减少了上传流量，也节省服务器存储空间。 &#xA;</description>
              <pubDate>Fri, 12 Jun 2020 00:00:00 +0000</pubDate>
          </item>
          <item>
              <title>36 * N 个工作中常用的 JavaScript 函数片段</title>
              <link>http://example.com/posts/jscode</link>
              <guid>http://example.com/posts/jscode</guid>
              <description>&#xA;&#xA;###来源:知乎&#xA;&#xA;&#xA;#### 最近在思否看到一个文章36个工作中常用的JavaScript函数片段。&#xA;&#xA;身为坑爹面试官（▄█▀█●），怎么能只有一个答案呢？&#xA;## 数组 Array&#xA;### 数组去重&#xA;#### 方案一：Set + ...&#xA;&#xA;```javascript&#xA;function noRepeat(arr) {&#xA;  return [...new Set(arr)];&#xA;}&#xA;noRepeat([1,2,3,1,2,3])&#xA;```&#xA;&#xA;#### 方案二：Set + Array.from&#xA;&#xA;&#xA;```javascript&#xA;function noRepeat(arr) {&#xA;  return Array.from(new Set(arr));&#xA;}&#xA;noRepeat([1,2,3,1,2,3])&#xA;```&#xA;#### 方案三：双重遍历比对下标&#xA;&#xA;&#xA;```javascript&#xA;function noRepeat(arr) {&#xA;  return arr.filter((v, idx)=&amp;gt;idx == arr.lastIndexOf(v))&#xA;}&#xA;noRepeat([1,2,3,1,2,3])&#xA;```&#xA;#### 方案四：单遍历 + Object 特性&#xA;&#xA;Object 的特性是 Key 不会重复。&#xA;这里使用 values 是因为可以保留类型，keys 会变成字符串。&#xA;&#xA;&#xA;```javascript&#xA;function noRepeat(arr) {&#xA;  return Object.values(arr.reduce((s,n)=&amp;gt;{&#xA;    s[n] = n;&#xA;    return s&#xA;  },{}))&#xA;}&#xA;noRepeat([1,2,3,1,2,3])&#xA;```&#xA;**后记**&#xA;&#xA;针对于上述的#### 方案，还有其他变种实现。&#xA;### 查找数组最大&#xA;#### 方案一：Math.max + ...&#xA;&#xA;&#xA;```javascript&#xA;function arrayMax(arr) {&#xA;  return Math.max(...arr);&#xA;}&#xA;arrayMax([-1,-4,5,2,0])&#xA;```&#xA;#### 方案二：Math.max + apply&#xA;&#xA;&#xA;```javascript&#xA;function arrayMax(arr) {&#xA;  return Math.max.apply(Math, arr)&#xA;}&#xA;arrayMax([-1,-4,5,2,0])&#xA;```&#xA;#### 方案三：Math.max + 遍历&#xA;&#xA;&#xA;```javascript&#xA;function arrayMax(arr) {&#xA;  return arr.reduce((s,n)=&amp;gt;Math.max(s, n))&#xA;}&#xA;arrayMax([-1,-4,5,2,0])&#xA;```&#xA;#### 方案四：比较、条件运算法 + 遍历&#xA;&#xA;&#xA;```javascript&#xA;function arrayMax(arr) {&#xA;  return arr.reduce((s,n)=&amp;gt;s&amp;gt;n?s:n)&#xA;}&#xA;arrayMax([-1,-4,5,2,0])&#xA;```&#xA;#### 方案五：排序&#xA;&#xA;&#xA;```javascript&#xA;function arrayMax(arr) {&#xA;  return arr.sort((n,m)=&amp;gt;m-n)[0]&#xA;}&#xA;arrayMax([-1,-4,5,2,0])&#xA;```&#xA;####  查找数组最小&#xA;&#xA;同上，不明白为什么要分成两个题目。&#xA;&#xA;`Math.max` 换成 `Math.mins&amp;gt;n?s:n `换成 `s&amp;lt;n?s:n(n,m)=&amp;gt;m-n `换成 `(n,m)=&amp;gt;n-m`，或者直接取最后一个元素&#xA;&#xA;### 返回已 size 为长度的数组分割的原数组&#xA;#### 方案一：Array.from + slice&#xA;&#xA;&#xA;```javascript&#xA;function chunk(arr, size = 1) {&#xA;  return Array.from(&#xA;    {&#xA;      length: Math.ceil(arr.length / size),&#xA;    },&#xA;    (v, i) =&amp;gt; arr.slice(i * size, i * size + size)&#xA;  );&#xA;}&#xA;chunk([1,2,3,4,5,6,7,8],3)&#xA;```&#xA;#### 方案二：Array.from + splice&#xA;&#xA;&#xA;```javascript&#xA;function chunk(arr, size = 1) {&#xA;  return Array.from(&#xA;    {&#xA;      length: Math.ceil(arr.length / size),&#xA;    },&#xA;    (v, i) =&amp;gt; arr.splice(0, size)&#xA;  );&#xA;}&#xA;chunk([1,2,3,4,5,6,7,8],3)&#xA;```&#xA;#### 方案三：遍历 + splice&#xA;&#xA;&#xA;```javascript&#xA;function chunk(arr, size = 1) {&#xA;    var _returnArr = [];&#xA;    while(arr.length){&#xA;        _returnArr.push(arr.splice(0, size))&#xA;    }&#xA;    return _returnArr&#xA;}&#xA;chunk([1,2,3,4,5,6,7,8],3)&#xA;```&#xA;### 检查数组中某元素出现的次数&#xA;#### 方案一：reduce&#xA;&#xA;&#xA;```javascript&#xA;function countOccurrences(arr, value) {&#xA;  return arr.reduce((a, v) =&amp;gt; (v === value ? a + 1 : a + 0), 0);&#xA;}&#xA;countOccurrences([1,2,3,4,5,1,2,1,2,3], 1)&#xA;```&#xA;#### 方案二：filter&#xA;&#xA;&#xA;```javascript&#xA;function countOccurrences(arr, value) {&#xA;  return arr.filter(v=&amp;gt;v===value).length&#xA;}&#xA;countOccurrences([1,2,3,4,5,1,2,1,2,3], 1)&#xA;&#xA;扁平化数组&#xA;#### 方案一：递归 + ...&#xA;&#xA;&#xA;```javascript&#xA;function flatten(arr, depth = -1) {&#xA;  if (depth === -1) {&#xA;    return [].concat(&#xA;      ...arr.map((v) =&amp;gt; (Array.isArray(v) ? this.flatten(v) : v))&#xA;    );&#xA;  }&#xA;  if (depth === 1) {&#xA;    return arr.reduce((a, v) =&amp;gt; a.concat(v), []);&#xA;  }&#xA;  return arr.reduce(&#xA;    (a, v) =&amp;gt; a.concat(Array.isArray(v) ? this.flatten(v, depth - 1) : v),&#xA;    []&#xA;  );&#xA;}&#xA;flatten([1,[2,[3]]])&#xA;&#xA;#### 方案二：es6 原生 flat&#xA;&#xA;&#xA;```javascript&#xA;function flatten(arr, depth = Infinity) {&#xA;  return arr.flat(depth)&#xA;}&#xA;flatten([1,[2,[3]]])&#xA;```&#xA;对比两个数组并且返回其中不同的元素&#xA;#### 方案一：filter + includes&#xA;&#xA;他原文有问题，以下方法的 4,5 没有返回&#xA;&#xA;&#xA;```javascript&#xA;function diffrence(arrA, arrB) {&#xA;  return arrA.filter((v) =&amp;gt; !arrB.includes(v));&#xA;}&#xA;diffrence([1,2,3], [3,4,5,2])&#xA;```&#xA;需要再操作一遍&#xA;&#xA;&#xA;```javascript&#xA;function diffrence(arrA, arrB) {&#xA;  return arrA.filter((v) =&amp;gt; !arrB.includes(v))&#xA;    .concat(arrB.filter((v) =&amp;gt; !arrA.includes(v)));&#xA;}&#xA;diffrence([1,2,3], [3,4,5,2])&#xA;```&#xA;#### 方案二：hash + 遍历&#xA;&#xA;算是#### 方案1的变种吧，优化了 includes 的性能。&#xA;返回两个数组中相同的元素&#xA;#### 方案一：filter + includes&#xA;&#xA;&#xA;```javascript&#xA;function intersection(arr1, arr2) {&#xA;  return arr2.filter((v) =&amp;gt; arr1.includes(v));&#xA;}&#xA;intersection([1,2,3], [3,4,5,2])&#xA;```&#xA;#### 方案二：同理变种用 hash&#xA;&#xA;&#xA;```javascript&#xA;function intersection(arr1, arr2) {&#xA;    var set = new Set(arr2)&#xA;  return arr1.filter((v) =&amp;gt; set.has(v));&#xA;}&#xA;intersection([1,2,3], [3,4,5,2])&#xA;```&#xA;从右删除 n 个元素&#xA;#### 方案一：slice&#xA;&#xA;&#xA;```javascript&#xA;function dropRight(arr, n = 0) {&#xA;  return n &amp;lt; arr.length ? arr.slice(0, arr.length - n) : [];&#xA;}&#xA;dropRight([1,2,3,4,5], 2)&#xA;```&#xA;#### 方案二: splice&#xA;&#xA;&#xA;```javascript&#xA;function dropRight(arr, n = 0) {&#xA;  return arr.splice(0, arr.length - n)&#xA;}&#xA;dropRight([1,2,3,4,5], 2)&#xA;```&#xA;#### 方案三: slice 另一种&#xA;&#xA;&#xA;```javascript&#xA;function dropRight(arr, n = 0) {&#xA;  return arr.slice(0, -n)&#xA;}&#xA;dropRight([1,2,3,4,5], 2)&#xA;```&#xA;#### 方案四: 修改 length&#xA;&#xA;&#xA;```javascript&#xA;function dropRight(arr, n = 0) {&#xA;    arr.length = Math.max(arr.length - n, 0)&#xA;    return arr&#xA;}&#xA;dropRight([1,2,3,4,5], 2)&#xA;```&#xA;截取第一个符合条件的元素及其以后的元素&#xA;#### 方案一：slice + 循环&#xA;&#xA;&#xA;```javascript&#xA;function dropElements(arr, fn) {&#xA;  while (arr.length &amp;amp;&amp;amp; !fn(arr[0])) arr = arr.slice(1);&#xA;  return arr;&#xA;}&#xA;dropElements([1,2,3,4,5,1,2,3], (v) =&amp;gt; v == 2)&#xA;```&#xA;#### 方案二：findIndex + slice&#xA;&#xA;&#xA;```javascript&#xA;function dropElements(arr, fn) {&#xA;  return arr.slice(Math.max(arr.findIndex(fn), 0));&#xA;}&#xA;dropElements([1,2,3,4,5,1,2,3], (v) =&amp;gt; v === 3)&#xA;```&#xA;#### 方案三：splice + 循环&#xA;&#xA;&#xA;```javascript&#xA;function dropElements(arr, fn) {&#xA;  while (arr.length &amp;amp;&amp;amp; !fn(arr[0])) arr.splice(0,1);&#xA;  return arr;&#xA;}&#xA;dropElements([1,2,3,4,5,1,2,3], (v) =&amp;gt; v == 2)&#xA;```&#xA;返回数组中下标间隔 nth 的元素&#xA;#### 方案一：filter&#xA;&#xA;&#xA;```javascript&#xA;function everyNth(arr, nth) {&#xA;  return arr.filter((v, i) =&amp;gt; i % nth === nth - 1);&#xA;}&#xA;everyNth([1,2,3,4,5,6,7,8], 2)&#xA;```&#xA;#### 方案二：#### 方案一修改判断条件&#xA;&#xA;&#xA;```javascript&#xA;function everyNth(arr, nth) {&#xA;  return arr.filter((v, i) =&amp;gt; (i+1) % nth === 0);&#xA;}&#xA;everyNth([1,2,3,4,5,6,7,8], 2)&#xA;```&#xA;返回数组中第 n 个元素（支持负数）&#xA;#### 方案一：slice&#xA;&#xA;&#xA;```javascript&#xA;function nthElement(arr, n = 0) {&#xA;  return (n &amp;gt;= 0 ? arr.slice(n, n + 1) : arr.slice(n))[0];&#xA;}&#xA;nthElement([1,2,3,4,5], 0)&#xA;nthElement([1,2,3,4,5], -1)&#xA;```&#xA;#### 方案二：三目运算符&#xA;&#xA;&#xA;```javascript&#xA;function nthElement(arr, n = 0) {&#xA;  return (n &amp;gt;= 0 ? arr[0] : arr[arr.length + n])&#xA;}&#xA;nthElement([1,2,3,4,5], 0)&#xA;nthElement([1,2,3,4,5], -1)&#xA;```&#xA;返回数组头元素&#xA;#### 方案一：&#xA;&#xA;&#xA;```javascript&#xA;function head(arr) {&#xA;  return arr[0];&#xA;}&#xA;head([1,2,3,4])&#xA;```&#xA;#### 方案二：&#xA;&#xA;&#xA;```javascript&#xA;function head(arr) {&#xA;  return arr.slice(0,1)[0];&#xA;}&#xA;head([1,2,3,4])&#xA;```&#xA;返回数组末尾元素&#xA;#### 方案一：&#xA;&#xA;&#xA;```javascript&#xA;function last(arr) {&#xA;  return arr[arr.length - 1];&#xA;}&#xA;```&#xA;#### 方案二：&#xA;&#xA;&#xA;```javascript&#xA;function last(arr) {&#xA;  return arr.slice(-1)[0];&#xA;}&#xA;last([1,2,3,4,5])&#xA;```&#xA;数组乱排&#xA;#### 方案一：洗牌算法&#xA;&#xA;&#xA;```javascript&#xA;function shuffle(arr) {&#xA;  let array = arr;&#xA;  let index = array.length;&#xA;&#xA;  while (index) {&#xA;    index -= 1;&#xA;    let randomInedx = Math.floor(Math.random() * index);&#xA;    let middleware = array[index];&#xA;    array[index] = array[randomInedx];&#xA;    array[randomInedx] = middleware;&#xA;  }&#xA;&#xA;  return array;&#xA;}&#xA;shuffle([1,2,3,4,5])&#xA;```&#xA;#### 方案二：sort + random&#xA;&#xA;&#xA;```javascript&#xA;function shuffle(arr) {&#xA;  return arr.sort((n,m)=&amp;gt;Math.random() - .5)&#xA;}&#xA;shuffle([1,2,3,4,5])&#xA;```&#xA;伪数组转换为数组&#xA;#### 方案一：Array.from&#xA;&#xA;`Array.from({length: 2})`&#xA;&#xA;#### 方案二：prototype.slice&#xA;&#xA;`Array.prototype.slice.call({length: 2,1:1})`&#xA;&#xA;#### 方案三：prototype.splice&#xA;&#xA;`Array.prototype.splice.call({length: 2,1:1},0)`&#xA;&#xA;浏览器对象 BOM&#xA;判读浏览器是否支持 CSS 属性&#xA;&#xA;```javascript&#xA;/**&#xA; * 告知浏览器支持的指定css属性情况&#xA; * @param {String} key - css属性，是属性的名字，不需要加前缀&#xA; * @returns {String} - 支持的属性情况&#xA; */&#xA;&#xA;&#xA;function validateCssKey(key) {&#xA;  const jsKey = toCamelCase(key); // 有些css属性是连字符号形成&#xA;  if (jsKey in document.documentElement.style) {&#xA;    return key;&#xA;  }&#xA;  let validKey = &amp;#34;&amp;#34;;&#xA;  // 属性名为前缀在js中的形式，属性值是前缀在css中的形式&#xA;  // 经尝试，Webkit 也可是首字母小写 webkit&#xA;  const prefixMap = {&#xA;    Webkit: &amp;#34;-webkit-&amp;#34;,&#xA;    Moz: &amp;#34;-moz-&amp;#34;,&#xA;    ms: &amp;#34;-ms-&amp;#34;,&#xA;    O: &amp;#34;-o-&amp;#34;,&#xA;  };&#xA;  for (const jsPrefix in prefixMap) {&#xA;    const styleKey = toCamelCase(`${jsPrefix}-${jsKey}`);&#xA;    if (styleKey in document.documentElement.style) {&#xA;      validKey = prefixMap[jsPrefix] + key;&#xA;      break;&#xA;    }&#xA;  }&#xA;  return validKey;&#xA;}&#xA;&#xA;/**&#xA; * 把有连字符号的字符串转化为驼峰命名法的字符串&#xA; */&#xA;&#xA;function toCamelCase(value) {&#xA;  return value.replace(/-(\w)/g, (matched, letter) =&amp;gt; {&#xA;    return letter.toUpperCase();&#xA;  });&#xA;}&#xA;&#xA;/**&#xA; * 检查浏览器是否支持某个css属性值（es6版）&#xA; * @param {String} key - 检查的属性值所属的css属性名&#xA; * @param {String} value - 要检查的css属性值（不要带前缀）&#xA; * @returns {String} - 返回浏览器支持的属性值&#xA; */&#xA;&#xA;function valiateCssValue(key, value) {&#xA;  const prefix = [&amp;#34;-o-&amp;#34;, &amp;#34;-ms-&amp;#34;, &amp;#34;-moz-&amp;#34;, &amp;#34;-webkit-&amp;#34;, &amp;#34;&amp;#34;];&#xA;  const prefixValue = prefix.map((item) =&amp;gt; {&#xA;    return item + value;&#xA;  });&#xA;  const element = document.createElement(&amp;#34;div&amp;#34;);&#xA;  const eleStyle = element.style;&#xA;  // 应用每个前缀的情况，且最后也要应用上没有前缀的情况，看最后浏览器起效的何种情况&#xA;  // 这就是最好在prefix里的最后一个元素是&amp;#39;&amp;#39;&#xA;  prefixValue.forEach((item) =&amp;gt; {&#xA;    eleStyle[key] = item;&#xA;  });&#xA;  return eleStyle[key];&#xA;}&#xA;&#xA;/**&#xA; * 检查浏览器是否支持某个css属性值&#xA; * @param {String} key - 检查的属性值所属的css属性名&#xA; * @param {String} value - 要检查的css属性值（不要带前缀）&#xA; * @returns {String} - 返回浏览器支持的属性值&#xA; */&#xA;&#xA;function valiateCssValue(key, value) {&#xA;  var prefix = [&amp;#34;-o-&amp;#34;, &amp;#34;-ms-&amp;#34;, &amp;#34;-moz-&amp;#34;, &amp;#34;-webkit-&amp;#34;, &amp;#34;&amp;#34;];&#xA;  var prefixValue = [];&#xA;  for (var i = 0; i &amp;lt; prefix.length; i++) {&#xA;    prefixValue.push(prefix[i] + value);&#xA;  }&#xA;  var element = document.createElement(&amp;#34;div&amp;#34;);&#xA;  var eleStyle = element.style;&#xA;  for (var j = 0; j &amp;lt; prefixValue.length; j++) {&#xA;    eleStyle[key] = prefixValue[j];&#xA;  }&#xA;  return eleStyle[key];&#xA;}&#xA;&#xA;&#xA;function validCss(key, value) {&#xA;  const validCss = validateCssKey(key);&#xA;  if (validCss) {&#xA;    return validCss;&#xA;  }&#xA;  return valiateCssValue(key, value);&#xA;}&#xA;```&#xA;https://segmentfault.com/a/11...&#xA;它里面有 forEach。&#xA;返回当前网页地址&#xA;#### 方案一：location&#xA;&#xA;&#xA;```javascript&#xA;function currentURL() {&#xA;  return window.location.href;&#xA;}&#xA;currentURL()&#xA;```&#xA;#### 方案二：a 标签&#xA;&#xA;&#xA;```javascript&#xA;function currentURL() {&#xA;  var el = document.createElement(&amp;#39;a&amp;#39;)&#xA;  el.href = &amp;#39;&amp;#39;&#xA;  return el.href&#xA;}&#xA;currentURL()&#xA;```&#xA;获取滚动条位置&#xA;&#xA;&#xA;```javascript&#xA;function getScrollPosition(el = window) {&#xA;  return {&#xA;    x: el.pageXOffset !== undefined ? el.pageXOffset : el.scrollLeft,&#xA;    y: el.pageYOffset !== undefined ? el.pageYOffset : el.scrollTop,&#xA;  };&#xA;}&#xA;```&#xA;获取 url 中的参数&#xA;#### 方案一：正则 + reduce&#xA;&#xA;&#xA;```javascript&#xA;function getURLParameters(url) {&#xA;  return url&#xA;    .match(/([^?=&amp;amp;]+)(=([^&amp;amp;]*))/g)&#xA;    .reduce(&#xA;      (a, v) =&amp;gt; (&#xA;        (a[v.slice(0, v.indexOf(&amp;#34;=&amp;#34;))] = v.slice(v.indexOf(&amp;#34;=&amp;#34;) + 1)), a&#xA;      ),&#xA;      {}&#xA;    );&#xA;}&#xA;getURLParameters(location.href)&#xA;```&#xA;#### 方案二：split + reduce&#xA;&#xA;&#xA;```javascript&#xA;function getURLParameters(url) {&#xA;  return url&#xA;    .split(&amp;#39;?&amp;#39;) //取？分割&#xA;    .slice(1) //不要第一部分&#xA;    .join() //拼接&#xA;    .split(&amp;#39;&amp;amp;&amp;#39;)//&amp;amp;分割&#xA;    .map(v=&amp;gt;v.split(&amp;#39;=&amp;#39;)) //=分割&#xA;    .reduce((s,n)=&amp;gt;{s[n[0]] = n[1];return s},{})&#xA;}&#xA;getURLParameters(location.href)&#xA;// getURLParameters(&amp;#39;&amp;#39;)&#xA;```&#xA;#### 方案三: URLSearchParams&#xA;页面跳转，是否记录在 history 中&#xA;#### 方案一：&#xA;&#xA;&#xA;```javascript&#xA;function redirect(url, asLink = true) {&#xA;  asLink ? (window.location.href = url) : window.location.replace(url);&#xA;}&#xA;```&#xA;#### 方案二：&#xA;&#xA;&#xA;```javascript&#xA;function redirect(url, asLink = true) {&#xA;  asLink ? window.location.assign(url) : window.location.replace(url);&#xA;}&#xA;```&#xA;滚动条回到顶部动画&#xA;#### 方案一： c - c / 8&#xA;&#xA;c 没有定义&#xA;&#xA;&#xA;```javascript&#xA;function scrollToTop() {&#xA;  const scrollTop =&#xA;    document.documentElement.scrollTop || document.body.scrollTop;&#xA;  if (scrollTop &amp;gt; 0) {&#xA;    window.requestAnimationFrame(scrollToTop);&#xA;    window.scrollTo(0, c - c / 8);&#xA;  } else {&#xA;    window.cancelAnimationFrame(scrollToTop);&#xA;  }&#xA;}&#xA;scrollToTop()&#xA;```&#xA;修正之后&#xA;&#xA;&#xA;```javascript&#xA;function scrollToTop() {&#xA;  const scrollTop =&#xA;    document.documentElement.scrollTop || document.body.scrollTop;&#xA;  if (scrollTop &amp;gt; 0) {&#xA;    window.requestAnimationFrame(scrollToTop);&#xA;    window.scrollTo(0, scrollTop - scrollTop / 8);&#xA;  } else {&#xA;    window.cancelAnimationFrame(scrollToTop);&#xA;  }&#xA;}&#xA;scrollToTop()&#xA;```&#xA;复制文本&#xA;#### 方案一：&#xA;&#xA;&#xA;```javascript&#xA;function copy(str) {&#xA;  const el = document.createElement(&amp;#34;textarea&amp;#34;);&#xA;  el.value = str;&#xA;  el.setAttribute(&amp;#34;readonly&amp;#34;, &amp;#34;&amp;#34;);&#xA;  el.style.position = &amp;#34;absolute&amp;#34;;&#xA;  el.style.left = &amp;#34;-9999px&amp;#34;;&#xA;  el.style.top = &amp;#34;-9999px&amp;#34;;&#xA;  document.body.appendChild(el);&#xA;  const selected =&#xA;    document.getSelection().rangeCount &amp;gt; 0&#xA;      ? document.getSelection().getRangeAt(0)&#xA;      : false;&#xA;  el.select();&#xA;  document.execCommand(&amp;#34;copy&amp;#34;);&#xA;  document.body.removeChild(el);&#xA;  if (selected) {&#xA;    document.getSelection().removeAllRanges();&#xA;    document.getSelection().addRange(selected);&#xA;  }&#xA;}&#xA;```&#xA;#### 方案二：cliboard.js&#xA;检测设备类型&#xA;#### 方案一： ua&#xA;&#xA;&#xA;```javascript&#xA;function detectDeviceType() {&#xA;  return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(&#xA;    navigator.userAgent&#xA;  )&#xA;    ? &amp;#34;Mobile&amp;#34;&#xA;    : &amp;#34;Desktop&amp;#34;;&#xA;}&#xA;detectDeviceType()&#xA;```&#xA;#### 方案二：事件属性&#xA;&#xA;&#xA;```javascript&#xA;function detectDeviceType() {&#xA;  return (&amp;#34;ontouchstart&amp;#34; in window || navigator.msMaxTouchPoints)&#xA;    ? &amp;#34;Mobile&amp;#34;&#xA;    : &amp;#34;Desktop&amp;#34;;&#xA;}&#xA;detectDeviceType()&#xA;```&#xA;Cookie&#xA;增&#xA;&#xA;&#xA;```javascript&#xA;function setCookie(key, value, expiredays) {&#xA;  var exdate = new Date();&#xA;  exdate.setDate(exdate.getDate() + expiredays);&#xA;  document.cookie =&#xA;    key +&#xA;    &amp;#34;=&amp;#34; +&#xA;    escape(value) +&#xA;    (expiredays == null ? &amp;#34;&amp;#34; : &amp;#34;;expires=&amp;#34; + exdate.toGMTString());&#xA;}&#xA;```&#xA;删&#xA;&#xA;&#xA;```javascript&#xA;function delCookie(name) {&#xA;  var exp = new Date();&#xA;  exp.setTime(exp.getTime() - 1);&#xA;  var cval = getCookie(name);&#xA;  if (cval != null) {&#xA;    document.cookie = name + &amp;#34;=&amp;#34; + cval + &amp;#34;;expires=&amp;#34; + exp.toGMTString();&#xA;  }&#xA;}&#xA;```&#xA;查&#xA;&#xA;&#xA;```javascript&#xA;function getCookie(name) {&#xA;  var arr,&#xA;    reg = new RegExp(&amp;#34;(^| )&amp;#34; + name + &amp;#34;=([^;]*)(;|$)&amp;#34;);&#xA;  if ((arr = document.cookie.match(reg))) {&#xA;    return arr[2];&#xA;  } else {&#xA;    return null;&#xA;  }&#xA;}&#xA;```&#xA;清空&#xA;&#xA;有时候我们想清空，但是又无法获取到所有的cookie。&#xA;这个时候我们可以了利用写满，然后再清空的办法。&#xA;日期 Date&#xA;时间戳转换为时间&#xA;&#xA;    默认为当前时间转换结果isMs 为时间戳是否为毫秒&#xA;&#xA;&#xA;```javascript&#xA;function timestampToTime(timestamp = Date.parse(new Date()), isMs = true) {&#xA;  const date = new Date(timestamp * (isMs ? 1 : 1000));&#xA;  return `${date.getFullYear()}-${&#xA;    date.getMonth() + 1 &amp;lt; 10 ? &amp;#34;0&amp;#34; + (date.getMonth() + 1) : date.getMonth() + 1&#xA;  }-${date.getDate()} ${date.getHours()}:${date.getMinutes()}:${date.getSeconds()}`;&#xA;}&#xA;```&#xA;    补位可以改成 padStart补位还可以改成 slice&#xA;&#xA;&#xA;如果做海外的话，还会有时区问题，一般我用moment解决。如果想看原生的&#xA;获取当前时间戳&#xA;&#xA;基于上一个想到的问题&#xA;#### 方案一：`Date.parse(new Date())`&#xA;#### 方案二：`Date.now()`&#xA;#### 方案三：`+new Date()`&#xA;文档对象 DOM&#xA;固定滚动条&#xA;```javascript&#xA;/**&#xA; * 功能描述：一些业务场景，如弹框出现时，需要禁止页面滚动，这是兼容安卓和 iOS 禁止页面滚动的解决#### 方案&#xA; */&#xA;&#xA;let scrollTop = 0;&#xA;&#xA;&#xA;&#xA;function preventScroll() {&#xA;  // 存储当前滚动位置&#xA;  scrollTop = window.scrollY;&#xA;&#xA;  // 将可滚动区域固定定位，可滚动区域高度为 0 后就不能滚动了&#xA;  document.body.style[&amp;#34;overflow-y&amp;#34;] = &amp;#34;hidden&amp;#34;;&#xA;  document.body.style.position = &amp;#34;fixed&amp;#34;;&#xA;  document.body.style.width = &amp;#34;100%&amp;#34;;&#xA;  document.body.style.top = -scrollTop + &amp;#34;px&amp;#34;;&#xA;  // document.body.style[&amp;#39;overscroll-behavior&amp;#39;] = &amp;#39;none&amp;#39;&#xA;}&#xA;&#xA;function recoverScroll() {&#xA;  document.body.style[&amp;#34;overflow-y&amp;#34;] = &amp;#34;auto&amp;#34;;&#xA;  document.body.style.position = &amp;#34;static&amp;#34;;&#xA;  // document.querySelector(&amp;#39;body&amp;#39;).style[&amp;#39;overscroll-behavior&amp;#39;] = &amp;#39;none&amp;#39;&#xA;&#xA;  window.scrollTo(0, scrollTop);&#xA;}&#xA;```&#xA;判断当前位置是否为页面底部&#xA;&#xA;    返回值为 true/false&#xA;&#xA;&#xA;```javascript&#xA;function bottomVisible() {&#xA;  return (&#xA;    document.documentElement.clientHeight + window.scrollY &amp;gt;=&#xA;    (document.documentElement.scrollHeight ||&#xA;      document.documentElement.clientHeight)&#xA;  );&#xA;}&#xA;```&#xA;判断元素是否在可视范围内&#xA;&#xA;  partiallyVisible 为是否为完全可见&#xA;&#xA;&#xA;```javascript&#xA;function elementIsVisibleInViewport(el, partiallyVisible = false) {&#xA;  const { top, left, bottom, right } = el.getBoundingClientRect();&#xA;&#xA;  return partiallyVisible&#xA;    ? ((top &amp;gt; 0 &amp;amp;&amp;amp; top &amp;lt; innerHeight) ||&#xA;        (bottom &amp;gt; 0 &amp;amp;&amp;amp; bottom &amp;lt; innerHeight)) &amp;amp;&amp;amp;&#xA;        ((left &amp;gt; 0 &amp;amp;&amp;amp; left &amp;lt; innerWidth) || (right &amp;gt; 0 &amp;amp;&amp;amp; right &amp;lt; innerWidth))&#xA;    : top &amp;gt;= 0 &amp;amp;&amp;amp; left &amp;gt;= 0 &amp;amp;&amp;amp; bottom &amp;lt;= innerHeight &amp;amp;&amp;amp; right &amp;lt;= innerWidth;&#xA;}&#xA;```&#xA;获取元素 css 样式&#xA;&#xA;&#xA;```javascript&#xA;function getStyle(el, ruleName) {&#xA;  return getComputedStyle(el, null).getPropertyValue(ruleName);&#xA;}&#xA;```&#xA;进入全屏&#xA;&#xA;&#xA;```javascript&#xA;function launchFullscreen(element) {&#xA;  if (element.requestFullscreen) {&#xA;    element.requestFullscreen();&#xA;  } else if (element.mozRequestFullScreen) {&#xA;    element.mozRequestFullScreen();&#xA;  } else if (element.msRequestFullscreen) {&#xA;    element.msRequestFullscreen();&#xA;  } else if (element.webkitRequestFullscreen) {&#xA;    element.webkitRequestFullScreen();&#xA;  }&#xA;}&#xA;&#xA;launchFullscreen(document.documentElement);&#xA;launchFullscreen(document.getElementById(&amp;#34;id&amp;#34;)); //某个元素进入全屏&#xA;```&#xA;退出全屏&#xA;&#xA;&#xA;```javascript&#xA;function exitFullscreen() {&#xA;  if (document.exitFullscreen) {&#xA;    document.exitFullscreen();&#xA;  } else if (document.msExitFullscreen) {&#xA;    document.msExitFullscreen();&#xA;  } else if (document.mozCancelFullScreen) {&#xA;    document.mozCancelFullScreen();&#xA;  } else if (document.webkitExitFullscreen) {&#xA;    document.webkitExitFullscreen();&#xA;  }&#xA;}&#xA;&#xA;exitFullscreen();&#xA;```&#xA;全屏事件&#xA;&#xA;```javascript&#xA;document.addEventListener(&amp;#34;fullscreenchange&amp;#34;, &#xA;function (e) {&#xA;  if (document.fullscreenElement) {&#xA;    console.log(&amp;#34;进入全屏&amp;#34;);&#xA;  } else {&#xA;    console.log(&amp;#34;退出全屏&amp;#34;);&#xA;  }&#xA;});&#xA;```&#xA;数字 Number&#xA;数字千分位分割&#xA;&#xA;&#xA;```javascript&#xA;function commafy(num) {&#xA;  return num.toString().indexOf(&amp;#34;.&amp;#34;) !== -1&#xA;    ? num.toLocaleString()&#xA;    : num.toString().replace(/(\d)(?=(?:\d{3})+$)/g, &amp;#34;$1,&amp;#34;);&#xA;}&#xA;commafy(1000)&#xA;```&#xA;生成随机数&#xA;&#xA;&#xA;&#xA;```javascript&#xA;function randomNum(min, max) {&#xA;  switch (arguments.length) {&#xA;    case 1:&#xA;      return parseInt(Math.random() * min + 1, 10);&#xA;    case 2:&#xA;      return parseInt(Math.random() * (max - min + 1) + min, 10);&#xA;    default:&#xA;      return 0;&#xA;  }&#xA;}&#xA;randomNum(1,10)&#xA;``` &#xA;</description>
              <pubDate>Fri, 12 Jun 2020 00:00:00 +0000</pubDate>
          </item>
          <item>
              <title>Underblog (Golang 写的静态博客引擎)</title>
              <link>http://example.com/posts/BlogTest</link>
              <guid>http://example.com/posts/BlogTest</guid>
              <description>&#xA;&#xA;原项目github地址:https://github.com/freetonik/underblog&#xA;&#xA;对他进行了一番魔改.....暂时还没上传.....&#xA;&#xA;&#xA;An extremely simple, fast static blog generator.&#xA;&#xA;## Deploy to Netlify&#xA;&#xA;[![Deploy to Netlify](https://www.netlify.com/img/deploy/button.svg)](https://app.netlify.com/start/deploy?repository=https://github.com/lucas-deangelis/underblog-template)&#xA;&#xA;## Install locally&#xA;&#xA;On MacOS:&#xA;&#xA;```&#xA;brew install freetonik/tap/underblog&#xA;```&#xA;&#xA;Docker:&#xA;&#xA;```&#xA;docker run --rm -it -v /path/to/your/blog:/blog freetonik/underblog&#xA;```&#xA;&#xA;Windows:&#xA;&#xA;Go to [releases](https://github.com/freetonik/underblog/releases) and download the latest binary marked &amp;#34;windows&amp;#34;.&#xA;&#xA;## How it works&#xA;&#xA;You only need 4 things:&#xA;&#xA;1. `index.html` template for blog&amp;#39;s index page.&#xA;2. `post.html` template for single post.&#xA;3. `css/styles.css` for CSS styles.&#xA;3. `markdown` folder.&#xA;&#xA;There is no front-matter. **Date** and **slug** are derived from the filename. **Title** is derived from the first line of markdown file. Make sure the first line starts with `#`.&#xA;&#xA;**Step 1:** create the following folder structure:&#xA;&#xA;```&#xA;.&#xA;├── css&#xA;│   └── styles.css&#xA;├── markdown&#xA;│   └── YYYY-MM-DD-Slug_1.md&#xA;│   └── YYYY-MM-DD-Slug_2.md&#xA;│   └── YYYY-MM-DD-Slug_3.md&#xA;├── index.html&#xA;├── post.html&#xA;```&#xA;&#xA;(See [/example](example))&#xA;&#xA;**Step 2:** run `underblog`.&#xA;&#xA;**Step 3:** Your site is generated in `public`.&#xA;&#xA;## Live preview&#xA;&#xA;Run underblog in watch mode:&#xA;&#xA;```&#xA;underblog -watch&#xA;```&#xA;&#xA;Then go to http://localhost:8080/. Changing markdown files will automatically re-generate the site.&#xA;&#xA;## Features&#xA;&#xA;- NO front matter&#xA;- NO themes&#xA;- NO JavaScript&#xA;- NO tags, categories, taxonomy&#xA;- NO template lookup logic&#xA;- NO plugins&#xA;- NO dependencies&#xA;&#xA;## Roadmap&#xA;&#xA;- [x] derive dates from filenames&#xA;- [ ] RSS generation&#xA;- [ ] Syntax highlighting for code with Chroma&#xA;- [x] live preview server&#xA;&#xA;---&#xA;&#xA;## Building&#xA;&#xA;In the root repository do:&#xA;&#xA;`make build`&#xA;</description>
              <pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate>
          </item>
      </channel>
  </rss>