
<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"/>
    <meta content="yes" name="apple-mobile-web-app-capable"/>
    <meta content="black" name="apple-mobile-web-app-status-bar-style"/>
    <meta http-equiv="Cache-Control" content="no-transform"/>
    <meta http-equiv="Cache-Control" content="no-siteapp"/>
    <meta content="telephone=no" name="format-detection"/>
    <link rel="shortcut icon" href="/static/images/pic.png" type="image/png"/>
    <meta name="renderer" content="webkit">
    <meta name="description" content="">
    <meta name="keywords" content="ArchLinux, ClarkQAQ, 个人博客, Blog, Code">
    <title>36 * N 个工作中常用的 JavaScript 函数片段 - Clark&#39;s Blog</title>
    <link rel="stylesheet" href="/static/css/style.css">
    <link rel="stylesheet" href="/static/css/strapdown.css">
</head>
<body>
<div class="wrapper">
    <header>
        <a href="/" class="logo"><img src="/static/images/user-head-image.png" alt="Clark&#39;s Blog"/></a>
        <div class="description">
            <h1>Clark&#39;s Blog</h1>
            <h2>在一个阳光明媚的午后,突然消失,永远消失.</h2>
            <nav>
                <div class="bitcron_nav_container">
                    <div class="bitcron_nav">
                        <div class="mixed_site_nav_wrap site_nav_wrap">
                            <ul class="mixed_site_nav site_nav sm sm-base">
                                <li><a href="/" class="selected active current nav__item">首页</a>
                                </li>

                            </ul>
                            <div class="clear clear_nav_inline_end">
                            </div>
                        </div>
                    </div>
                    <div class="clear clear_nav_end">
                    </div>
                </div>
            </nav>
        </div>
    </header>

    <main>
<article class="content">

    <h1>36 * N 个工作中常用的 JavaScript 函数片段</h1>
    <div class="meta">
            <span class="item">日期:<time>2020-06-12</time></span>
        <span class="item">标签:默认(未实现)</span>
    </div>
    <div class="post">
        <div class="md_block" id="markdown">

        </div>
    </div>
    <br />
    <br />
</article>
    <script src="/static/js/strapdown.js"></script>
    <script>
		document.getElementById("markdown").innerHTML = "\n\n###来源:知乎\n\n\n#### 最近在思否看到一个文章36个工作中常用的JavaScript函数片段。\n\n身为坑爹面试官（▄█▀█●），怎么能只有一个答案呢？\n## 数组 Array\n### 数组去重\n#### 方案一：Set \x2b ...\n\n```javascript\nfunction noRepeat(arr) {\n  return [...new Set(arr)];\n}\nnoRepeat([1,2,3,1,2,3])\n```\n\n#### 方案二：Set \x2b Array.from\n\n\n```javascript\nfunction noRepeat(arr) {\n  return Array.from(new Set(arr));\n}\nnoRepeat([1,2,3,1,2,3])\n```\n#### 方案三：双重遍历比对下标\n\n\n```javascript\nfunction noRepeat(arr) {\n  return arr.filter((v, idx)=\x3eidx == arr.lastIndexOf(v))\n}\nnoRepeat([1,2,3,1,2,3])\n```\n#### 方案四：单遍历 \x2b Object 特性\n\nObject 的特性是 Key 不会重复。\n这里使用 values 是因为可以保留类型，keys 会变成字符串。\n\n\n```javascript\nfunction noRepeat(arr) {\n  return Object.values(arr.reduce((s,n)=\x3e{\n    s[n] = n;\n    return s\n  },{}))\n}\nnoRepeat([1,2,3,1,2,3])\n```\n**后记**\n\n针对于上述的#### 方案，还有其他变种实现。\n### 查找数组最大\n#### 方案一：Math.max \x2b ...\n\n\n```javascript\nfunction arrayMax(arr) {\n  return Math.max(...arr);\n}\narrayMax([-1,-4,5,2,0])\n```\n#### 方案二：Math.max \x2b apply\n\n\n```javascript\nfunction arrayMax(arr) {\n  return Math.max.apply(Math, arr)\n}\narrayMax([-1,-4,5,2,0])\n```\n#### 方案三：Math.max \x2b 遍历\n\n\n```javascript\nfunction arrayMax(arr) {\n  return arr.reduce((s,n)=\x3eMath.max(s, n))\n}\narrayMax([-1,-4,5,2,0])\n```\n#### 方案四：比较、条件运算法 \x2b 遍历\n\n\n```javascript\nfunction arrayMax(arr) {\n  return arr.reduce((s,n)=\x3es\x3en?s:n)\n}\narrayMax([-1,-4,5,2,0])\n```\n#### 方案五：排序\n\n\n```javascript\nfunction arrayMax(arr) {\n  return arr.sort((n,m)=\x3em-n)[0]\n}\narrayMax([-1,-4,5,2,0])\n```\n####  查找数组最小\n\n同上，不明白为什么要分成两个题目。\n\n`Math.max` 换成 `Math.mins\x3en?s:n `换成 `s\x3cn?s:n(n,m)=\x3em-n `换成 `(n,m)=\x3en-m`，或者直接取最后一个元素\n\n### 返回已 size 为长度的数组分割的原数组\n#### 方案一：Array.from \x2b slice\n\n\n```javascript\nfunction chunk(arr, size = 1) {\n  return Array.from(\n    {\n      length: Math.ceil(arr.length \/ size),\n    },\n    (v, i) =\x3e arr.slice(i * size, i * size \x2b size)\n  );\n}\nchunk([1,2,3,4,5,6,7,8],3)\n```\n#### 方案二：Array.from \x2b splice\n\n\n```javascript\nfunction chunk(arr, size = 1) {\n  return Array.from(\n    {\n      length: Math.ceil(arr.length \/ size),\n    },\n    (v, i) =\x3e arr.splice(0, size)\n  );\n}\nchunk([1,2,3,4,5,6,7,8],3)\n```\n#### 方案三：遍历 \x2b splice\n\n\n```javascript\nfunction chunk(arr, size = 1) {\n    var _returnArr = [];\n    while(arr.length){\n        _returnArr.push(arr.splice(0, size))\n    }\n    return _returnArr\n}\nchunk([1,2,3,4,5,6,7,8],3)\n```\n### 检查数组中某元素出现的次数\n#### 方案一：reduce\n\n\n```javascript\nfunction countOccurrences(arr, value) {\n  return arr.reduce((a, v) =\x3e (v === value ? a \x2b 1 : a \x2b 0), 0);\n}\ncountOccurrences([1,2,3,4,5,1,2,1,2,3], 1)\n```\n#### 方案二：filter\n\n\n```javascript\nfunction countOccurrences(arr, value) {\n  return arr.filter(v=\x3ev===value).length\n}\ncountOccurrences([1,2,3,4,5,1,2,1,2,3], 1)\n\n扁平化数组\n#### 方案一：递归 \x2b ...\n\n\n```javascript\nfunction flatten(arr, depth = -1) {\n  if (depth === -1) {\n    return [].concat(\n      ...arr.map((v) =\x3e (Array.isArray(v) ? this.flatten(v) : v))\n    );\n  }\n  if (depth === 1) {\n    return arr.reduce((a, v) =\x3e a.concat(v), []);\n  }\n  return arr.reduce(\n    (a, v) =\x3e a.concat(Array.isArray(v) ? this.flatten(v, depth - 1) : v),\n    []\n  );\n}\nflatten([1,[2,[3]]])\n\n#### 方案二：es6 原生 flat\n\n\n```javascript\nfunction flatten(arr, depth = Infinity) {\n  return arr.flat(depth)\n}\nflatten([1,[2,[3]]])\n```\n对比两个数组并且返回其中不同的元素\n#### 方案一：filter \x2b includes\n\n他原文有问题，以下方法的 4,5 没有返回\n\n\n```javascript\nfunction diffrence(arrA, arrB) {\n  return arrA.filter((v) =\x3e !arrB.includes(v));\n}\ndiffrence([1,2,3], [3,4,5,2])\n```\n需要再操作一遍\n\n\n```javascript\nfunction diffrence(arrA, arrB) {\n  return arrA.filter((v) =\x3e !arrB.includes(v))\n    .concat(arrB.filter((v) =\x3e !arrA.includes(v)));\n}\ndiffrence([1,2,3], [3,4,5,2])\n```\n#### 方案二：hash \x2b 遍历\n\n算是#### 方案1的变种吧，优化了 includes 的性能。\n返回两个数组中相同的元素\n#### 方案一：filter \x2b includes\n\n\n```javascript\nfunction intersection(arr1, arr2) {\n  return arr2.filter((v) =\x3e arr1.includes(v));\n}\nintersection([1,2,3], [3,4,5,2])\n```\n#### 方案二：同理变种用 hash\n\n\n```javascript\nfunction intersection(arr1, arr2) {\n    var set = new Set(arr2)\n  return arr1.filter((v) =\x3e set.has(v));\n}\nintersection([1,2,3], [3,4,5,2])\n```\n从右删除 n 个元素\n#### 方案一：slice\n\n\n```javascript\nfunction dropRight(arr, n = 0) {\n  return n \x3c arr.length ? arr.slice(0, arr.length - n) : [];\n}\ndropRight([1,2,3,4,5], 2)\n```\n#### 方案二: splice\n\n\n```javascript\nfunction dropRight(arr, n = 0) {\n  return arr.splice(0, arr.length - n)\n}\ndropRight([1,2,3,4,5], 2)\n```\n#### 方案三: slice 另一种\n\n\n```javascript\nfunction dropRight(arr, n = 0) {\n  return arr.slice(0, -n)\n}\ndropRight([1,2,3,4,5], 2)\n```\n#### 方案四: 修改 length\n\n\n```javascript\nfunction dropRight(arr, n = 0) {\n    arr.length = Math.max(arr.length - n, 0)\n    return arr\n}\ndropRight([1,2,3,4,5], 2)\n```\n截取第一个符合条件的元素及其以后的元素\n#### 方案一：slice \x2b 循环\n\n\n```javascript\nfunction dropElements(arr, fn) {\n  while (arr.length \x26\x26 !fn(arr[0])) arr = arr.slice(1);\n  return arr;\n}\ndropElements([1,2,3,4,5,1,2,3], (v) =\x3e v == 2)\n```\n#### 方案二：findIndex \x2b slice\n\n\n```javascript\nfunction dropElements(arr, fn) {\n  return arr.slice(Math.max(arr.findIndex(fn), 0));\n}\ndropElements([1,2,3,4,5,1,2,3], (v) =\x3e v === 3)\n```\n#### 方案三：splice \x2b 循环\n\n\n```javascript\nfunction dropElements(arr, fn) {\n  while (arr.length \x26\x26 !fn(arr[0])) arr.splice(0,1);\n  return arr;\n}\ndropElements([1,2,3,4,5,1,2,3], (v) =\x3e v == 2)\n```\n返回数组中下标间隔 nth 的元素\n#### 方案一：filter\n\n\n```javascript\nfunction everyNth(arr, nth) {\n  return arr.filter((v, i) =\x3e i % nth === nth - 1);\n}\neveryNth([1,2,3,4,5,6,7,8], 2)\n```\n#### 方案二：#### 方案一修改判断条件\n\n\n```javascript\nfunction everyNth(arr, nth) {\n  return arr.filter((v, i) =\x3e (i\x2b1) % nth === 0);\n}\neveryNth([1,2,3,4,5,6,7,8], 2)\n```\n返回数组中第 n 个元素（支持负数）\n#### 方案一：slice\n\n\n```javascript\nfunction nthElement(arr, n = 0) {\n  return (n \x3e= 0 ? arr.slice(n, n \x2b 1) : arr.slice(n))[0];\n}\nnthElement([1,2,3,4,5], 0)\nnthElement([1,2,3,4,5], -1)\n```\n#### 方案二：三目运算符\n\n\n```javascript\nfunction nthElement(arr, n = 0) {\n  return (n \x3e= 0 ? arr[0] : arr[arr.length \x2b n])\n}\nnthElement([1,2,3,4,5], 0)\nnthElement([1,2,3,4,5], -1)\n```\n返回数组头元素\n#### 方案一：\n\n\n```javascript\nfunction head(arr) {\n  return arr[0];\n}\nhead([1,2,3,4])\n```\n#### 方案二：\n\n\n```javascript\nfunction head(arr) {\n  return arr.slice(0,1)[0];\n}\nhead([1,2,3,4])\n```\n返回数组末尾元素\n#### 方案一：\n\n\n```javascript\nfunction last(arr) {\n  return arr[arr.length - 1];\n}\n```\n#### 方案二：\n\n\n```javascript\nfunction last(arr) {\n  return arr.slice(-1)[0];\n}\nlast([1,2,3,4,5])\n```\n数组乱排\n#### 方案一：洗牌算法\n\n\n```javascript\nfunction shuffle(arr) {\n  let array = arr;\n  let index = array.length;\n\n  while (index) {\n    index -= 1;\n    let randomInedx = Math.floor(Math.random() * index);\n    let middleware = array[index];\n    array[index] = array[randomInedx];\n    array[randomInedx] = middleware;\n  }\n\n  return array;\n}\nshuffle([1,2,3,4,5])\n```\n#### 方案二：sort \x2b random\n\n\n```javascript\nfunction shuffle(arr) {\n  return arr.sort((n,m)=\x3eMath.random() - .5)\n}\nshuffle([1,2,3,4,5])\n```\n伪数组转换为数组\n#### 方案一：Array.from\n\n`Array.from({length: 2})`\n\n#### 方案二：prototype.slice\n\n`Array.prototype.slice.call({length: 2,1:1})`\n\n#### 方案三：prototype.splice\n\n`Array.prototype.splice.call({length: 2,1:1},0)`\n\n浏览器对象 BOM\n判读浏览器是否支持 CSS 属性\n\n```javascript\n\/**\n * 告知浏览器支持的指定css属性情况\n * @param {String} key - css属性，是属性的名字，不需要加前缀\n * @returns {String} - 支持的属性情况\n *\/\n\n\nfunction validateCssKey(key) {\n  const jsKey = toCamelCase(key); \/\/ 有些css属性是连字符号形成\n  if (jsKey in document.documentElement.style) {\n    return key;\n  }\n  let validKey = \x22\x22;\n  \/\/ 属性名为前缀在js中的形式，属性值是前缀在css中的形式\n  \/\/ 经尝试，Webkit 也可是首字母小写 webkit\n  const prefixMap = {\n    Webkit: \x22-webkit-\x22,\n    Moz: \x22-moz-\x22,\n    ms: \x22-ms-\x22,\n    O: \x22-o-\x22,\n  };\n  for (const jsPrefix in prefixMap) {\n    const styleKey = toCamelCase(`${jsPrefix}-${jsKey}`);\n    if (styleKey in document.documentElement.style) {\n      validKey = prefixMap[jsPrefix] \x2b key;\n      break;\n    }\n  }\n  return validKey;\n}\n\n\/**\n * 把有连字符号的字符串转化为驼峰命名法的字符串\n *\/\n\nfunction toCamelCase(value) {\n  return value.replace(\/-(\\w)\/g, (matched, letter) =\x3e {\n    return letter.toUpperCase();\n  });\n}\n\n\/**\n * 检查浏览器是否支持某个css属性值（es6版）\n * @param {String} key - 检查的属性值所属的css属性名\n * @param {String} value - 要检查的css属性值（不要带前缀）\n * @returns {String} - 返回浏览器支持的属性值\n *\/\n\nfunction valiateCssValue(key, value) {\n  const prefix = [\x22-o-\x22, \x22-ms-\x22, \x22-moz-\x22, \x22-webkit-\x22, \x22\x22];\n  const prefixValue = prefix.map((item) =\x3e {\n    return item \x2b value;\n  });\n  const element = document.createElement(\x22div\x22);\n  const eleStyle = element.style;\n  \/\/ 应用每个前缀的情况，且最后也要应用上没有前缀的情况，看最后浏览器起效的何种情况\n  \/\/ 这就是最好在prefix里的最后一个元素是\x27\x27\n  prefixValue.forEach((item) =\x3e {\n    eleStyle[key] = item;\n  });\n  return eleStyle[key];\n}\n\n\/**\n * 检查浏览器是否支持某个css属性值\n * @param {String} key - 检查的属性值所属的css属性名\n * @param {String} value - 要检查的css属性值（不要带前缀）\n * @returns {String} - 返回浏览器支持的属性值\n *\/\n\nfunction valiateCssValue(key, value) {\n  var prefix = [\x22-o-\x22, \x22-ms-\x22, \x22-moz-\x22, \x22-webkit-\x22, \x22\x22];\n  var prefixValue = [];\n  for (var i = 0; i \x3c prefix.length; i\x2b\x2b) {\n    prefixValue.push(prefix[i] \x2b value);\n  }\n  var element = document.createElement(\x22div\x22);\n  var eleStyle = element.style;\n  for (var j = 0; j \x3c prefixValue.length; j\x2b\x2b) {\n    eleStyle[key] = prefixValue[j];\n  }\n  return eleStyle[key];\n}\n\n\nfunction validCss(key, value) {\n  const validCss = validateCssKey(key);\n  if (validCss) {\n    return validCss;\n  }\n  return valiateCssValue(key, value);\n}\n```\nhttps:\/\/segmentfault.com\/a\/11...\n它里面有 forEach。\n返回当前网页地址\n#### 方案一：location\n\n\n```javascript\nfunction currentURL() {\n  return window.location.href;\n}\ncurrentURL()\n```\n#### 方案二：a 标签\n\n\n```javascript\nfunction currentURL() {\n  var el = document.createElement(\x27a\x27)\n  el.href = \x27\x27\n  return el.href\n}\ncurrentURL()\n```\n获取滚动条位置\n\n\n```javascript\nfunction getScrollPosition(el = window) {\n  return {\n    x: el.pageXOffset !== undefined ? el.pageXOffset : el.scrollLeft,\n    y: el.pageYOffset !== undefined ? el.pageYOffset : el.scrollTop,\n  };\n}\n```\n获取 url 中的参数\n#### 方案一：正则 \x2b reduce\n\n\n```javascript\nfunction getURLParameters(url) {\n  return url\n    .match(\/([^?=\x26]\x2b)(=([^\x26]*))\/g)\n    .reduce(\n      (a, v) =\x3e (\n        (a[v.slice(0, v.indexOf(\x22=\x22))] = v.slice(v.indexOf(\x22=\x22) \x2b 1)), a\n      ),\n      {}\n    );\n}\ngetURLParameters(location.href)\n```\n#### 方案二：split \x2b reduce\n\n\n```javascript\nfunction getURLParameters(url) {\n  return url\n    .split(\x27?\x27) \/\/取？分割\n    .slice(1) \/\/不要第一部分\n    .join() \/\/拼接\n    .split(\x27\x26\x27)\/\/\x26分割\n    .map(v=\x3ev.split(\x27=\x27)) \/\/=分割\n    .reduce((s,n)=\x3e{s[n[0]] = n[1];return s},{})\n}\ngetURLParameters(location.href)\n\/\/ getURLParameters(\x27\x27)\n```\n#### 方案三: URLSearchParams\n页面跳转，是否记录在 history 中\n#### 方案一：\n\n\n```javascript\nfunction redirect(url, asLink = true) {\n  asLink ? (window.location.href = url) : window.location.replace(url);\n}\n```\n#### 方案二：\n\n\n```javascript\nfunction redirect(url, asLink = true) {\n  asLink ? window.location.assign(url) : window.location.replace(url);\n}\n```\n滚动条回到顶部动画\n#### 方案一： c - c \/ 8\n\nc 没有定义\n\n\n```javascript\nfunction scrollToTop() {\n  const scrollTop =\n    document.documentElement.scrollTop || document.body.scrollTop;\n  if (scrollTop \x3e 0) {\n    window.requestAnimationFrame(scrollToTop);\n    window.scrollTo(0, c - c \/ 8);\n  } else {\n    window.cancelAnimationFrame(scrollToTop);\n  }\n}\nscrollToTop()\n```\n修正之后\n\n\n```javascript\nfunction scrollToTop() {\n  const scrollTop =\n    document.documentElement.scrollTop || document.body.scrollTop;\n  if (scrollTop \x3e 0) {\n    window.requestAnimationFrame(scrollToTop);\n    window.scrollTo(0, scrollTop - scrollTop \/ 8);\n  } else {\n    window.cancelAnimationFrame(scrollToTop);\n  }\n}\nscrollToTop()\n```\n复制文本\n#### 方案一：\n\n\n```javascript\nfunction copy(str) {\n  const el = document.createElement(\x22textarea\x22);\n  el.value = str;\n  el.setAttribute(\x22readonly\x22, \x22\x22);\n  el.style.position = \x22absolute\x22;\n  el.style.left = \x22-9999px\x22;\n  el.style.top = \x22-9999px\x22;\n  document.body.appendChild(el);\n  const selected =\n    document.getSelection().rangeCount \x3e 0\n      ? document.getSelection().getRangeAt(0)\n      : false;\n  el.select();\n  document.execCommand(\x22copy\x22);\n  document.body.removeChild(el);\n  if (selected) {\n    document.getSelection().removeAllRanges();\n    document.getSelection().addRange(selected);\n  }\n}\n```\n#### 方案二：cliboard.js\n检测设备类型\n#### 方案一： ua\n\n\n```javascript\nfunction detectDeviceType() {\n  return \/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini\/i.test(\n    navigator.userAgent\n  )\n    ? \x22Mobile\x22\n    : \x22Desktop\x22;\n}\ndetectDeviceType()\n```\n#### 方案二：事件属性\n\n\n```javascript\nfunction detectDeviceType() {\n  return (\x22ontouchstart\x22 in window || navigator.msMaxTouchPoints)\n    ? \x22Mobile\x22\n    : \x22Desktop\x22;\n}\ndetectDeviceType()\n```\nCookie\n增\n\n\n```javascript\nfunction setCookie(key, value, expiredays) {\n  var exdate = new Date();\n  exdate.setDate(exdate.getDate() \x2b expiredays);\n  document.cookie =\n    key \x2b\n    \x22=\x22 \x2b\n    escape(value) \x2b\n    (expiredays == null ? \x22\x22 : \x22;expires=\x22 \x2b exdate.toGMTString());\n}\n```\n删\n\n\n```javascript\nfunction delCookie(name) {\n  var exp = new Date();\n  exp.setTime(exp.getTime() - 1);\n  var cval = getCookie(name);\n  if (cval != null) {\n    document.cookie = name \x2b \x22=\x22 \x2b cval \x2b \x22;expires=\x22 \x2b exp.toGMTString();\n  }\n}\n```\n查\n\n\n```javascript\nfunction getCookie(name) {\n  var arr,\n    reg = new RegExp(\x22(^| )\x22 \x2b name \x2b \x22=([^;]*)(;|$)\x22);\n  if ((arr = document.cookie.match(reg))) {\n    return arr[2];\n  } else {\n    return null;\n  }\n}\n```\n清空\n\n有时候我们想清空，但是又无法获取到所有的cookie。\n这个时候我们可以了利用写满，然后再清空的办法。\n日期 Date\n时间戳转换为时间\n\n    默认为当前时间转换结果isMs 为时间戳是否为毫秒\n\n\n```javascript\nfunction timestampToTime(timestamp = Date.parse(new Date()), isMs = true) {\n  const date = new Date(timestamp * (isMs ? 1 : 1000));\n  return `${date.getFullYear()}-${\n    date.getMonth() \x2b 1 \x3c 10 ? \x220\x22 \x2b (date.getMonth() \x2b 1) : date.getMonth() \x2b 1\n  }-${date.getDate()} ${date.getHours()}:${date.getMinutes()}:${date.getSeconds()}`;\n}\n```\n    补位可以改成 padStart补位还可以改成 slice\n\n\n如果做海外的话，还会有时区问题，一般我用moment解决。如果想看原生的\n获取当前时间戳\n\n基于上一个想到的问题\n#### 方案一：`Date.parse(new Date())`\n#### 方案二：`Date.now()`\n#### 方案三：`\x2bnew Date()`\n文档对象 DOM\n固定滚动条\n```javascript\n\/**\n * 功能描述：一些业务场景，如弹框出现时，需要禁止页面滚动，这是兼容安卓和 iOS 禁止页面滚动的解决#### 方案\n *\/\n\nlet scrollTop = 0;\n\n\n\nfunction preventScroll() {\n  \/\/ 存储当前滚动位置\n  scrollTop = window.scrollY;\n\n  \/\/ 将可滚动区域固定定位，可滚动区域高度为 0 后就不能滚动了\n  document.body.style[\x22overflow-y\x22] = \x22hidden\x22;\n  document.body.style.position = \x22fixed\x22;\n  document.body.style.width = \x22100%\x22;\n  document.body.style.top = -scrollTop \x2b \x22px\x22;\n  \/\/ document.body.style[\x27overscroll-behavior\x27] = \x27none\x27\n}\n\nfunction recoverScroll() {\n  document.body.style[\x22overflow-y\x22] = \x22auto\x22;\n  document.body.style.position = \x22static\x22;\n  \/\/ document.querySelector(\x27body\x27).style[\x27overscroll-behavior\x27] = \x27none\x27\n\n  window.scrollTo(0, scrollTop);\n}\n```\n判断当前位置是否为页面底部\n\n    返回值为 true\/false\n\n\n```javascript\nfunction bottomVisible() {\n  return (\n    document.documentElement.clientHeight \x2b window.scrollY \x3e=\n    (document.documentElement.scrollHeight ||\n      document.documentElement.clientHeight)\n  );\n}\n```\n判断元素是否在可视范围内\n\n  partiallyVisible 为是否为完全可见\n\n\n```javascript\nfunction elementIsVisibleInViewport(el, partiallyVisible = false) {\n  const { top, left, bottom, right } = el.getBoundingClientRect();\n\n  return partiallyVisible\n    ? ((top \x3e 0 \x26\x26 top \x3c innerHeight) ||\n        (bottom \x3e 0 \x26\x26 bottom \x3c innerHeight)) \x26\x26\n        ((left \x3e 0 \x26\x26 left \x3c innerWidth) || (right \x3e 0 \x26\x26 right \x3c innerWidth))\n    : top \x3e= 0 \x26\x26 left \x3e= 0 \x26\x26 bottom \x3c= innerHeight \x26\x26 right \x3c= innerWidth;\n}\n```\n获取元素 css 样式\n\n\n```javascript\nfunction getStyle(el, ruleName) {\n  return getComputedStyle(el, null).getPropertyValue(ruleName);\n}\n```\n进入全屏\n\n\n```javascript\nfunction launchFullscreen(element) {\n  if (element.requestFullscreen) {\n    element.requestFullscreen();\n  } else if (element.mozRequestFullScreen) {\n    element.mozRequestFullScreen();\n  } else if (element.msRequestFullscreen) {\n    element.msRequestFullscreen();\n  } else if (element.webkitRequestFullscreen) {\n    element.webkitRequestFullScreen();\n  }\n}\n\nlaunchFullscreen(document.documentElement);\nlaunchFullscreen(document.getElementById(\x22id\x22)); \/\/某个元素进入全屏\n```\n退出全屏\n\n\n```javascript\nfunction exitFullscreen() {\n  if (document.exitFullscreen) {\n    document.exitFullscreen();\n  } else if (document.msExitFullscreen) {\n    document.msExitFullscreen();\n  } else if (document.mozCancelFullScreen) {\n    document.mozCancelFullScreen();\n  } else if (document.webkitExitFullscreen) {\n    document.webkitExitFullscreen();\n  }\n}\n\nexitFullscreen();\n```\n全屏事件\n\n```javascript\ndocument.addEventListener(\x22fullscreenchange\x22, \nfunction (e) {\n  if (document.fullscreenElement) {\n    console.log(\x22进入全屏\x22);\n  } else {\n    console.log(\x22退出全屏\x22);\n  }\n});\n```\n数字 Number\n数字千分位分割\n\n\n```javascript\nfunction commafy(num) {\n  return num.toString().indexOf(\x22.\x22) !== -1\n    ? num.toLocaleString()\n    : num.toString().replace(\/(\\d)(?=(?:\\d{3})\x2b$)\/g, \x22$1,\x22);\n}\ncommafy(1000)\n```\n生成随机数\n\n\n\n```javascript\nfunction randomNum(min, max) {\n  switch (arguments.length) {\n    case 1:\n      return parseInt(Math.random() * min \x2b 1, 10);\n    case 2:\n      return parseInt(Math.random() * (max - min \x2b 1) \x2b min, 10);\n    default:\n      return 0;\n  }\n}\nrandomNum(1,10)\n``` \n";
		markdown("markdown");
	</script>
</main>
</div>
    <footer>
        <span>ClarkQAQ - ♥</span>
        <div>友情链接:
        <a href="http://blog.claraqwq.com/" target="_blank" title="ClaraQWQ的博客">Clara</a>
		</div>
        <div class="powered_by">
            <span>© CopyRight</span>
            <a href="http://clarkabe.top" target="_blank">ClarkQAQ</a>
            <a href="#" target="_blank">Fantasy</a>
        </div>
        <div class="footer_slogan">
        </div>
    </footer>

    <script>
		(function() {
			var OriginTitle = document.title;
			var titleTime;
			document.addEventListener('visibilitychange', function () {
				if (document.hidden) {
					document.title = "喔唷,崩溃啦!";
					clearTimeout(titleTime);
				}else {
					document.title = "诶!=w=又好了!";
					titleTime = setTimeout(function () {
						document.title = OriginTitle;
					}, 2000);
				}
			});
		 }());
    </script>
</body>
</html>